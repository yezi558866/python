变量：只能用字母和“_”
%s 取变量值，后面跟 %变量名。
输入变量：raw_input()
判断变量类型：type()
输入变量raw_input()的type类型为str。
转换为int类型，则：int(变量名)
打印颜色：\33[32m------\33[0m
范围表示：range(1,50)
if：条件判断
for：循环
while：循环
break：终止语句，满足条件退出循环操作。
continue：满足条件继续进行循环。
def sayhi()：定义函数用def。
import os：引用系统模块
from os import *: 导入os模块内所有。
help(os.system)：查看帮助。
os.system('ls'):调用系统命令列出当前目录内容。
模块：当前目录下.py就可以当做模块。
python数据结构：列表、元组、字典。
列表：有序项目的数据结构。shoplist = ['apple', 'mango', 'carrot', 'banana']
元组：
字典：


方法、模块、对象



return:
	--函数被调用会返回一个指定值；
	--默认返回None
	--return 返回值
	--返回值可以是任意类型
	--return执行后，函数终止
	--区分返回值和打印
lambda：
	--快速定义单行的最小函数
	--返回函数对象
map:
	--将传入的函数依次作用于序列的每个元素。结果作为新的Iterator返回。
	--list(map(f, range(1,10)))
filter:
	--和map()类似，接收一个函数和一个序列。函数作用于每个元素，根据返回值是True还是False决定是否保留该元素。
reduce:
	--把一个函数作用于一个序列，此函数需接收两个参热，reduce继续将结果与下个元素做累计计算。
	--reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
	--from functools import reduce
yield:
	--把一个函数变成一个generator.
	--调用fab(5)不会执行fab函数，而是返回一个iterable对象。
	--for循环中，每次循环都会执行fab函数内部代码，执行到yield b时，fab函数就返回一个迭代值，下次迭代时，代码从yield b的下一条语句继续执行，而函数本身变量和上次中断执行前是完全一样。
	--在generator function中，如果没有return，则默认执行至函数结束，如果执行过程中return，则直接抛出Stopiteration终止迭代。
sorted:
	--可以对list进行排序；
	--接收key函数实现自定义排序。
	--进行反向排序，可传入第三个参数：reverse=True.
try/except/else/finally:
	--try/except主要处理程序正常执行过程中出现的一些异常。
	--try/finally主要用于无论是否发生异常，均需要执行清理工作场合。
	--执行try语句，发生异常则进行except；无异常则进入else；无论异常与否，均执行finally。
读写文件：
	--open()，打开文件。
	--read()，一次性读取文件全部内容至内存，用str表示。
	--close(),关闭文件。
	--with open() as f:自动调用close()方法。
	--read(size),每次读取size个字节内容。
	--readline(),每次读取一行内容。
	--readlines(),一次读取所有内容并按行返回list.
StringIO_BytesIO:
	--StringIO在内存中读写str。
	--BytesIO在内存中读写bytes。
序列化：
	--把变量从内存变成可存储或传输的过程成为序列化。
	--import pinkle
	--pickle.dumps()把任意对象序列换成一个bytes，就可以写入文件。
	--pickle.dump()直接把对象序列化后写入file-like Object。
	--pickle.loads()反序列化，把对象从磁盘读入内存时，先把内容读到一个bytes。
	--pickle.load()直接从一个file-like Object中直接反序列化出对象。
JSON：
	--import json
	--dict对象可以序列化为JSON的{}
	--json.dumps(class, default=lambda obj: obj.__dict__) 类实例序列化为json
	--json.loads(json_str, object_hook=dict2class) json反序列化为类实例对象
Process:
	--from multiprocessing import Process
	--Process类代表一个进程对象
	--p = Process(target=run_proc, args=('test',))
	--p.start()
	--p.join()
Pool:
	--from multiprocessing import Pool
	--如果需要大量的子进程，可通过进程池的方式批量创建子进程。
	--p = Pool(4)
	--p.apply_async(long_time_task, args=(i,))
	--p.close()
	--p.join()
subprocess:
	--创建子进程，且控制子进程输入输出。
	--import subprocess
	--r = subprocess.call(['nslookup', 'www.python.org'])
	--控制输入输出：
	p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	--output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
	--print(output.decode('utf-8'))
	--print('Exit code:', p.returncode)
Queue：
	--实现进程间通信。
	--from multiprocessing import Queue
	--q = Queue()
	--pw = Process(target=write, args=(q,))
	--pr = Process(target=read, args=(q,))
	--pw.start()
	--q.put(value)
	--pr.start()
	--q.get(True)
	--pw.join()
	--pr.terminate()
threading:
	--启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行。
	--import threading
	--任何进程默认都会启动一个线程，我们称之为主线程，主线程又可以启动新的线程，主线程名字MainThread。
	--threading模块的current_thread()函数，返回当前线程的实例。
	--创建一个锁，lock = threading.Lock()
	--获取锁，lock.acquire()
	--释放锁，lock.release()